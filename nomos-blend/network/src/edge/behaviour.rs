use std::{
    collections::{HashMap, VecDeque},
    task::{Context, Poll, Waker},
};

use libp2p::{
    core::{transport::PortUse, Endpoint},
    swarm::{
        dial_opts::{DialOpts, PeerCondition},
        ConnectionDenied, ConnectionId, DialFailure, FromSwarm, NetworkBehaviour, THandler,
        THandlerInEvent, THandlerOutEvent, ToSwarm,
    },
    Multiaddr, PeerId,
};
use nomos_blend_scheduling::membership::Membership;
use rand::RngCore;

use super::{
    error::Error,
    handler::{EdgeToCoreBlendConnectionHandler, FailureReason, ToBehaviour},
};

const LOG_TARGET: &str = "blend::network::edge::behaviour";

/// A [`NetworkBehaviour`] for an edge node,
/// which sends data messages to one of core nodes in the Blend network.
///
/// It sends a dialing request to the Swarm for a random core node,
/// whenever a data message is scheduled.
/// Once the connection is established and fully negotiated,
/// it sends one of the messages scheduled.
/// After that, it closes the substream.
///
/// If any error occurs during the process,
/// it restarts the process by scheduling a new dialing request for the message.
pub struct Behaviour<Rng> {
    /// Queue of events to yield to the swarm.
    events: VecDeque<ToSwarm<EventToSwarm, ()>>,
    /// Messages to be sent once a new connection is established.
    pending_messages: HashMap<(PeerId, ConnectionId), Vec<u8>>,
    /// Waker that handles polling
    waker: Option<Waker>,
    // TODO: Replace with the session stream and make this a non-Option
    //       https://github.com/logos-co/nomos/issues/1462
    current_membership: Option<Membership<PeerId>>,
    rng: Rng,
}

#[derive(Debug)]
pub enum EventToSwarm {
    /// Notify the swarm that the message was sent successfully.
    MessageSuccess(Vec<u8>),
}

impl<Rng> NetworkBehaviour for Behaviour<Rng>
where
    Rng: RngCore + 'static,
{
    type ConnectionHandler = EdgeToCoreBlendConnectionHandler;
    type ToSwarm = EventToSwarm;

    fn handle_established_inbound_connection(
        &mut self,
        _connection_id: ConnectionId,
        _peer_id: PeerId,
        _local_addr: &Multiaddr,
        _remote_addr: &Multiaddr,
    ) -> Result<THandler<Self>, ConnectionDenied> {
        tracing::debug!(target: LOG_TARGET, "Connection established from a non-core node. Creating a connection handler with DroppedState.");
        Ok(EdgeToCoreBlendConnectionHandler::new_dropped())
    }

    fn handle_established_outbound_connection(
        &mut self,
        connection_id: ConnectionId,
        peer_id: PeerId,
        _addr: &Multiaddr,
        _role_override: Endpoint,
        _port_use: PortUse,
    ) -> Result<THandler<Self>, ConnectionDenied> {
        if !self.is_core_node(&peer_id) {
            tracing::debug!(target: LOG_TARGET, "Connection established to a non-core node. Creating a connection handler with DroppedState.");
            self.pending_messages.remove(&(peer_id, connection_id));
            return Ok(EdgeToCoreBlendConnectionHandler::new_dropped());
        }

        let Some(message) = self.pending_messages.remove(&(peer_id, connection_id)) else {
            tracing::debug!(target: LOG_TARGET, "No message assigned to this connection. Creating a connection handler with DroppedState.");
            return Ok(EdgeToCoreBlendConnectionHandler::new_dropped());
        };

        Ok(EdgeToCoreBlendConnectionHandler::new(message))
    }

    /// Informs the behaviour about an event from the [`Swarm`].
    fn on_swarm_event(&mut self, event: FromSwarm) {
        if let FromSwarm::DialFailure(failure) = event {
            self.handle_dial_failure(failure);
        }
    }

    /// Handles an event generated by the [`EdgeToCoreBlendConnectionHandler`]
    /// dedicated to the connection identified by `peer_id` and `connection_id`.
    fn on_connection_handler_event(
        &mut self,
        peer_id: PeerId,
        connection_id: ConnectionId,
        event: THandlerOutEvent<Self>,
    ) {
        match event {
            ToBehaviour::MessageSuccess(message) => {
                self.handle_message_success(peer_id, connection_id, message);
            }
            ToBehaviour::SendError(reason) => {
                self.handle_send_error(peer_id, connection_id, &reason);
            }
        }
    }

    /// Polls for things that swarm should do.
    fn poll(
        &mut self,
        cx: &mut Context<'_>,
    ) -> Poll<ToSwarm<Self::ToSwarm, THandlerInEvent<Self>>> {
        if let Some(event) = self.events.pop_front() {
            Poll::Ready(event)
        } else {
            self.waker = Some(cx.waker().clone());
            Poll::Pending
        }
    }
}

impl<Rng> Behaviour<Rng>
where
    Rng: RngCore,
{
    #[must_use]
    pub fn new(current_membership: Option<Membership<PeerId>>, rng: Rng) -> Self {
        Self {
            events: VecDeque::new(),
            pending_messages: HashMap::new(),
            waker: None,
            current_membership,
            rng,
        }
    }

    /// Checks if the given peer is a core node.
    fn is_core_node(&self, peer_id: &PeerId) -> bool {
        // If no membership is provided (for tests), we assume all peers are core nodes.
        let Some(membership) = &self.current_membership else {
            return true;
        };
        membership.contains_remote(peer_id)
    }

    /// Schedules sending a message by dialing a random node
    pub fn send_message(&mut self, message: Vec<u8>) -> Result<(), Error> {
        self.schedule_dial(message)
    }

    /// Schedules dialing to a random node.
    fn schedule_dial(&mut self, message: Vec<u8>) -> Result<(), Error> {
        tracing::debug!(target: LOG_TARGET, "Scheduling a new dial");

        let Some(membership) = &self.current_membership else {
            return Err(Error::NoPeers);
        };

        let node = membership
            .choose_remote_nodes(&mut self.rng, 1)
            .next()
            .ok_or(Error::NoPeers)?;

        let opts = DialOpts::peer_id(node.id)
            .condition(PeerCondition::Always)
            .addresses(vec![node.address.clone()])
            .build();
        self.pending_messages
            .insert((node.id, opts.connection_id()), message);
        self.events.push_back(ToSwarm::Dial { opts });
        self.try_wake();
        Ok(())
    }

    /// Schedules a [`EventToSwarm`] to be sent to the swarm.
    fn schedule_event_to_swarm(&mut self, event: EventToSwarm) {
        self.events.push_back(ToSwarm::GenerateEvent(event));
        self.try_wake();
    }

    /// Handles [`FromSwarm::DialFailure`] event from the swarm
    /// by rescheduling a new dial if necessary.
    fn handle_dial_failure(&mut self, failure: DialFailure) {
        tracing::error!(target: LOG_TARGET, "Dial failure: {failure:?}");

        // Reschedule a new dial only if the failure is from
        // the connection that this NetworkBehaviour has requested.
        let Some(peer_id) = failure.peer_id else {
            return;
        };
        let Some(message) = self
            .pending_messages
            .remove(&(peer_id, failure.connection_id))
        else {
            return;
        };
        tracing::debug!(target: LOG_TARGET, "Rescheduling dial");
        if let Err(e) = self.schedule_dial(message) {
            tracing::error!(target: LOG_TARGET, "Failed to reschedule dial: {e}");
        }
    }

    /// Handles [`ToBehaviour::MessageSuccess`] event from the connection
    /// handler by removing the message from the [`Self::pending_messages`]
    /// and scheduling a [`EventToSwarm::MessageSuccess`] to the swarm.
    fn handle_message_success(
        &mut self,
        peer_id: PeerId,
        connection_id: ConnectionId,
        message: Vec<u8>,
    ) {
        tracing::debug!(target: LOG_TARGET, "Message sent successfully to {peer_id} on connection {connection_id}");
        self.pending_messages.remove(&(peer_id, connection_id));
        self.schedule_event_to_swarm(EventToSwarm::MessageSuccess(message));
    }

    /// Handles [`ToBehaviour::SendError`] event from the connection handler
    /// by rescheduling a new dial.
    fn handle_send_error(
        &mut self,
        peer_id: PeerId,
        connection_id: ConnectionId,
        reason: &FailureReason,
    ) {
        tracing::error!(target: LOG_TARGET, "Failed to send message. Reason: {reason:?}. Rescheduling dial.");
        if let Some(message) = self.pending_messages.remove(&(peer_id, connection_id)) {
            if let Err(e) = self.schedule_dial(message) {
                tracing::error!(target: LOG_TARGET, "Failed to reschedule dial: {e}");
            }
        }
    }

    fn try_wake(&mut self) {
        if let Some(waker) = self.waker.take() {
            waker.wake();
        }
    }
}
