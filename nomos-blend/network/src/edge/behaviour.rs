use std::{
    collections::{HashSet, VecDeque},
    task::{Context, Poll, Waker},
};

use libp2p::{
    core::{transport::PortUse, Endpoint},
    swarm::{
        dial_opts::{DialOpts, PeerCondition},
        ConnectionDenied, ConnectionId, DialFailure, FromSwarm, NetworkBehaviour, NotifyHandler,
        THandler, THandlerInEvent, THandlerOutEvent, ToSwarm,
    },
    Multiaddr, PeerId,
};
use nomos_blend_scheduling::membership::Membership;
use rand::RngCore;

use super::{
    error::Error,
    handler::{EdgeToCoreBlendConnectionHandler, FailureReason, FromBehaviour, ToBehaviour},
};

const LOG_TARGET: &str = "blend::network::edge::behaviour";

/// A [`NetworkBehaviour`] for an edge node,
/// which sends data messages to one of core nodes in the Blend network.
///
/// It sends a dialing request to the Swarm for a random core node,
/// whenever a data message is scheduled.
/// Once the connection is established and fully negotiated,
/// it sends one of the messages scheduled.
/// After that, it closes the substream.
///
/// It continously tracks whether additional dialing is needed.
/// Whenever it receives [`DialFailure`] or [`FailureReason::UpgradeError`],
/// it requests new dialings if the number of requested dials is less than
/// the number of scheduled messages.
pub struct Behaviour<Rng> {
    /// Queue of events to yield to the swarm.
    events: VecDeque<ToSwarm<EventToSwarm, FromBehaviour>>,
    /// Pending messages to be sent once a new connection is established.
    pending_messages: VecDeque<Vec<u8>>,
    /// Requested dials to track whether additional dialing is needed.
    /// - Added when a new dial is scheduled.
    /// - Removed
    ///   - when the dial fails.
    ///   - when the connection becomes ready to send.
    ///   - when the connection has been dropped before being ready to send.
    requested_dials: HashSet<(PeerId, ConnectionId)>,
    /// Waker that handles polling
    waker: Option<Waker>,
    // TODO: Replace with the session stream and make this a non-Option
    //       https://github.com/logos-co/nomos/issues/1462
    current_membership: Option<Membership<PeerId>>,
    rng: Rng,
}

#[derive(Debug)]
pub enum EventToSwarm {
    /// Notify the swarm that the message was sent successfully.
    MessageSuccess(Vec<u8>),
}

impl<Rng> NetworkBehaviour for Behaviour<Rng>
where
    Rng: RngCore + 'static,
{
    type ConnectionHandler = EdgeToCoreBlendConnectionHandler;
    type ToSwarm = EventToSwarm;

    fn handle_established_inbound_connection(
        &mut self,
        _connection_id: ConnectionId,
        _peer_id: PeerId,
        _local_addr: &Multiaddr,
        _remote_addr: &Multiaddr,
    ) -> Result<THandler<Self>, ConnectionDenied> {
        Err(ConnectionDenied::new(
            ConnectionDeniedReason::InboundNotAllowed,
        ))
    }

    fn handle_established_outbound_connection(
        &mut self,
        _connection_id: ConnectionId,
        peer_id: PeerId,
        _addr: &Multiaddr,
        _role_override: Endpoint,
        _port_use: PortUse,
    ) -> Result<THandler<Self>, ConnectionDenied> {
        // If no membership is provided (for tests), we assume all peers are core nodes.
        let Some(membership) = &self.current_membership else {
            return Ok(EdgeToCoreBlendConnectionHandler::new());
        };
        if membership.contains_remote(&peer_id) {
            Ok(EdgeToCoreBlendConnectionHandler::new())
        } else {
            Err(ConnectionDenied::new(
                ConnectionDeniedReason::OutboundToEdgeNodeNotAllowed,
            ))
        }
    }

    /// Informs the behaviour about an event from the [`Swarm`].
    fn on_swarm_event(&mut self, event: FromSwarm) {
        if let FromSwarm::DialFailure(failure) = event {
            self.handle_dial_failure(failure);
        }
    }

    /// Handles an event generated by the [`EdgeToCoreBlendConnectionHandler`]
    /// dedicated to the connection identified by `peer_id` and `connection_id`.
    fn on_connection_handler_event(
        &mut self,
        peer_id: PeerId,
        connection_id: ConnectionId,
        event: THandlerOutEvent<Self>,
    ) {
        match event {
            ToBehaviour::ReadyToSend => {
                self.handle_ready_to_send(peer_id, connection_id);
            }
            ToBehaviour::MessageSuccess(message) => {
                self.schedule_event_to_swarm(EventToSwarm::MessageSuccess(message));
            }
            ToBehaviour::Dropped(reason) => {
                self.handle_dropped_connection(peer_id, connection_id, reason.as_ref());
            }
        }
    }

    /// Polls for things that swarm should do.
    fn poll(
        &mut self,
        cx: &mut Context<'_>,
    ) -> Poll<ToSwarm<Self::ToSwarm, THandlerInEvent<Self>>> {
        if let Some(event) = self.events.pop_front() {
            Poll::Ready(event)
        } else {
            self.waker = Some(cx.waker().clone());
            Poll::Pending
        }
    }
}

impl<Rng> Behaviour<Rng>
where
    Rng: RngCore,
{
    #[must_use]
    pub fn new(current_membership: Option<Membership<PeerId>>, rng: Rng) -> Self {
        Self {
            events: VecDeque::new(),
            pending_messages: VecDeque::new(),
            requested_dials: HashSet::new(),
            waker: None,
            current_membership,
            rng,
        }
    }

    /// Schedules sending a message by dialing a random node
    pub fn send_message(&mut self, message: Vec<u8>) -> Result<(), Error> {
        self.pending_messages.push_back(message);
        self.schedule_dial_if_needed()
    }

    /// Schedules a new dial if requested dials are less than pending messages.
    fn schedule_dial_if_needed(&mut self) -> Result<(), Error> {
        if self.pending_messages.len() > self.requested_dials.len() {
            self.schedule_dial()?;
        }
        Ok(())
    }

    /// Schedules dialing to a random node.
    fn schedule_dial(&mut self) -> Result<(), Error> {
        tracing::debug!(target: LOG_TARGET, "Scheduling a new dial");

        let Some(membership) = &self.current_membership else {
            return Err(Error::NoPeers);
        };

        let node = membership
            .choose_remote_nodes(&mut self.rng, 1)
            .next()
            .ok_or(Error::NoPeers)?;

        let opts = self.new_dial_opts(node.id, &node.address);
        self.requested_dials.insert((node.id, opts.connection_id()));
        self.events.push_back(ToSwarm::Dial { opts });
        self.try_wake();
        Ok(())
    }

    /// Creates a new [`DialOpts`] for the given peer.
    /// Repeats until a new connection ID (not exist in [`requested_dials`]) is
    /// generated.
    fn new_dial_opts(&self, peer_id: PeerId, address: &Multiaddr) -> DialOpts {
        loop {
            let opts = DialOpts::peer_id(peer_id)
                .condition(PeerCondition::DisconnectedAndNotDialing)
                .addresses(vec![address.clone()])
                .build();
            if !self
                .requested_dials
                .contains(&(peer_id, opts.connection_id()))
            {
                return opts;
            }
        }
    }

    /// Schedules sending a message to the peer that is connected/negotiated.
    /// Returns `true` if there was a message to schedule, `false` otherwise.
    fn schedule_send_message(&mut self, peer_id: PeerId, connection_id: ConnectionId) -> bool {
        let Some(message) = self.pending_messages.pop_front() else {
            return false;
        };
        self.events.push_back(ToSwarm::NotifyHandler {
            peer_id,
            handler: NotifyHandler::One(connection_id),
            event: FromBehaviour::Message(message),
        });
        self.try_wake();
        true
    }

    /// Schedules a [`EventToSwarm`] to be sent to the swarm.
    fn schedule_event_to_swarm(&mut self, event: EventToSwarm) {
        self.events.push_back(ToSwarm::GenerateEvent(event));
        self.try_wake();
    }

    fn schedule_drop_substream(&mut self, peer_id: PeerId, connection_id: ConnectionId) {
        tracing::debug!(target: LOG_TARGET, "Dropping substream: peer:{peer_id}, connection_id:{connection_id}");
        self.events.push_back(ToSwarm::NotifyHandler {
            peer_id,
            handler: NotifyHandler::One(connection_id),
            event: FromBehaviour::DropSubstream,
        });
        self.try_wake();
    }

    /// Handles [`ToBehaviour::ReadyToSend`] event from the connection handler.
    fn handle_ready_to_send(&mut self, peer_id: PeerId, connection_id: ConnectionId) {
        tracing::debug!(target: LOG_TARGET, "Conn is ready to send: peer:{peer_id}, connection_id:{connection_id}");
        self.requested_dials.remove(&(peer_id, connection_id));
        if !self.schedule_send_message(peer_id, connection_id) {
            // There was no message to send. Drop the substream.
            self.schedule_drop_substream(peer_id, connection_id);
        }
    }

    /// Handles [`ToBehaviour::Dropped`] event from the connection handler.
    fn handle_dropped_connection(
        &mut self,
        peer_id: PeerId,
        connection_id: ConnectionId,
        reason: Option<&FailureReason>,
    ) {
        self.requested_dials.remove(&(peer_id, connection_id));
        if matches!(reason, Some(FailureReason::UpgradeError)) {
            tracing::error!(target: LOG_TARGET, "Upgrade error: peer:{peer_id}, connection_id:{connection_id}");
            if let Err(e) = self.schedule_dial_if_needed() {
                tracing::error!(target: LOG_TARGET, "Failed to schedule dial: {e}");
            }
        }
    }

    /// Handles [`FromSwarm::DialFailure`] event from the swarm.
    fn handle_dial_failure(&mut self, failure: DialFailure) {
        tracing::error!(target: LOG_TARGET, "Dial failure: {failure:?}");
        if let Some(peer_id) = failure.peer_id {
            self.requested_dials
                .remove(&(peer_id, failure.connection_id));
        }
        if let Err(e) = self.schedule_dial_if_needed() {
            tracing::error!(target: LOG_TARGET, "Failed to schedule dial: {e}");
        }
    }

    fn try_wake(&mut self) {
        if let Some(waker) = self.waker.take() {
            waker.wake();
        }
    }

    // TODO: Remove this method once the session stream is implemented.
    //       https://github.com/logos-co/nomos/issues/1462
    pub fn set_membership(&mut self, membership: Membership<PeerId>) {
        self.current_membership = Some(membership);
        if let Err(e) = self.schedule_dial_if_needed() {
            tracing::error!(target: LOG_TARGET, "Failed to schedule dial: {e}");
        }
    }
}

#[derive(Debug, thiserror::Error)]
enum ConnectionDeniedReason {
    #[error("Inbound connection not allowed for edge node")]
    InboundNotAllowed,
    #[error("Outbound connection to edge node is not allowed")]
    OutboundToEdgeNodeNotAllowed,
}
