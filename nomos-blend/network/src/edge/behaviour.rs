use std::{
    collections::{HashMap, VecDeque},
    task::{Context, Poll, Waker},
};

use libp2p::{
    core::{transport::PortUse, Endpoint},
    swarm::{
        dial_opts::{DialOpts, PeerCondition},
        ConnectionDenied, ConnectionId, DialFailure, FromSwarm, NetworkBehaviour, THandler,
        THandlerInEvent, THandlerOutEvent, ToSwarm,
    },
    Multiaddr, PeerId,
};
use nomos_blend_scheduling::membership::Membership;
use rand::RngCore;

use super::{
    error::Error,
    handler::{EdgeToCoreBlendConnectionHandler, SendError, ToBehaviour},
};

const LOG_TARGET: &str = "blend::network::edge::behaviour";

/// A [`NetworkBehaviour`] for an edge node,
/// which sends data messages to one of core nodes in the Blend network.
///
/// It sends a dialing request to the Swarm for a random core node,
/// whenever a data message is scheduled.
/// Once the connection is established and fully negotiated,
/// it sends one of the messages scheduled.
/// After that, it closes the substream.
///
/// If any error occurs during the process,
/// it restarts the process by scheduling a new dialing request for the message.
pub struct Behaviour<Rng> {
    /// Queue of events to yield to the swarm.
    events: VecDeque<ToSwarm<EventToSwarm, ()>>,
    /// Dials that are not completed yet.
    /// Each dial has a message assigned to it, so once the dial completes,
    /// a [`ConnectionHandler`] can be created for that message.
    /// If the dial fails, another dial can be scheduled for that message.
    pending_dials: HashMap<(PeerId, ConnectionId), Vec<u8>>,
    /// Waker that handles polling
    waker: Option<Waker>,
    // TODO: Replace with the session stream and make this a non-Option
    //       https://github.com/logos-co/nomos/issues/1462
    current_membership: Option<Membership<PeerId>>,
    rng: Rng,
}

#[derive(Debug)]
pub enum EventToSwarm {
    /// Notify the swarm that the message was sent successfully.
    MessageSuccess(Vec<u8>),
}

impl<Rng> NetworkBehaviour for Behaviour<Rng>
where
    Rng: RngCore + 'static,
{
    type ConnectionHandler = EdgeToCoreBlendConnectionHandler;
    type ToSwarm = EventToSwarm;

    fn handle_established_inbound_connection(
        &mut self,
        _connection_id: ConnectionId,
        _peer_id: PeerId,
        _local_addr: &Multiaddr,
        _remote_addr: &Multiaddr,
    ) -> Result<THandler<Self>, ConnectionDenied> {
        let reason = ConnectionDeniedReason::InboundNotAllowed;
        tracing::warn!(target: LOG_TARGET, "Denying the connection: {reason:?}");
        Err(ConnectionDenied::new(Box::new(reason)))
    }

    fn handle_established_outbound_connection(
        &mut self,
        connection_id: ConnectionId,
        peer_id: PeerId,
        _addr: &Multiaddr,
        _role_override: Endpoint,
        _port_use: PortUse,
    ) -> Result<THandler<Self>, ConnectionDenied> {
        if !self.is_core_node(&peer_id) {
            let reason = ConnectionDeniedReason::OutboundToEdgeNodeNotAllowed;
            tracing::warn!(target: LOG_TARGET, "Denying the connection: {reason:?}");
            self.pending_dials.remove(&(peer_id, connection_id));
            return Err(ConnectionDenied::new(Box::new(reason)));
        }

        let Some(message) = self.pending_dials.remove(&(peer_id, connection_id)) else {
            let reason = ConnectionDeniedReason::NotRequested;
            tracing::warn!(target: LOG_TARGET, "Denying the connection: {reason:?}");
            return Err(ConnectionDenied::new(Box::new(reason)));
        };

        Ok(EdgeToCoreBlendConnectionHandler::new(message))
    }

    /// Informs the behaviour about an event from the [`Swarm`].
    fn on_swarm_event(&mut self, event: FromSwarm) {
        if let FromSwarm::DialFailure(failure) = event {
            self.handle_dial_failure(failure);
        }
    }

    /// Handles an event generated by the [`EdgeToCoreBlendConnectionHandler`]
    /// dedicated to the connection identified by `peer_id` and `connection_id`.
    fn on_connection_handler_event(
        &mut self,
        peer_id: PeerId,
        connection_id: ConnectionId,
        event: THandlerOutEvent<Self>,
    ) {
        match event {
            ToBehaviour::MessageSuccess(message) => {
                self.handle_message_success(peer_id, connection_id, message);
            }
            ToBehaviour::SendError(error) => {
                self.handle_send_error(error);
            }
        }
    }

    /// Polls for things that swarm should do.
    fn poll(
        &mut self,
        cx: &mut Context<'_>,
    ) -> Poll<ToSwarm<Self::ToSwarm, THandlerInEvent<Self>>> {
        if let Some(event) = self.events.pop_front() {
            Poll::Ready(event)
        } else {
            self.waker = Some(cx.waker().clone());
            Poll::Pending
        }
    }
}

#[derive(Debug, thiserror::Error)]
enum ConnectionDeniedReason {
    #[error("Inbound connection is not allowed")]
    InboundNotAllowed,
    #[error("Outbound connection to an edge node is not allowed")]
    OutboundToEdgeNodeNotAllowed,
    #[error("Connection was not requested by this NetworkBehaviour")]
    NotRequested,
}

impl<Rng> Behaviour<Rng> {
    #[must_use]
    pub fn new(current_membership: Option<Membership<PeerId>>, rng: Rng) -> Self {
        Self {
            events: VecDeque::new(),
            pending_dials: HashMap::new(),
            waker: None,
            current_membership,
            rng,
        }
    }

    /// Checks if the given peer is a core node.
    fn is_core_node(&self, peer_id: &PeerId) -> bool {
        // If no membership is provided (for tests), we assume all peers are core nodes.
        let Some(membership) = &self.current_membership else {
            return true;
        };
        membership.contains_remote(peer_id)
    }

    /// Schedules a [`EventToSwarm`] to be sent to the swarm.
    fn schedule_event_to_swarm(&mut self, event: EventToSwarm) {
        self.events.push_back(ToSwarm::GenerateEvent(event));
        self.try_wake();
    }

    fn get_messsage_of_failed_dial(&mut self, failure: DialFailure) -> Option<Vec<u8>> {
        let peer_id = failure.peer_id?;
        self.pending_dials
            .remove(&(peer_id, failure.connection_id))
            .or_else(|| {
                tracing::warn!(
                    target: LOG_TARGET,
                    "The failed dial that was not requested by this behaviour.",
                );
                None
            })
    }

    /// Handles [`ToBehaviour::MessageSuccess`] event from the connection
    /// handler by removing the message from the [`Self::pending_messages`]
    /// and scheduling a [`EventToSwarm::MessageSuccess`] to the swarm.
    fn handle_message_success(
        &mut self,
        peer_id: PeerId,
        connection_id: ConnectionId,
        message: Vec<u8>,
    ) {
        tracing::debug!(target: LOG_TARGET, "Message sent successfully to {peer_id} on connection {connection_id}");
        self.pending_dials.remove(&(peer_id, connection_id));
        self.schedule_event_to_swarm(EventToSwarm::MessageSuccess(message));
    }

    fn try_wake(&mut self) {
        if let Some(waker) = self.waker.take() {
            waker.wake();
        }
    }
}

impl<Rng> Behaviour<Rng>
where
    Rng: RngCore,
{
    /// Schedules sending a message by dialing a random node
    pub fn send_message(&mut self, message: Vec<u8>) -> Result<(), Error> {
        self.schedule_dial(message)
    }

    /// Schedules dialing to a random node.
    fn schedule_dial(&mut self, message: Vec<u8>) -> Result<(), Error> {
        tracing::debug!(target: LOG_TARGET, "Scheduling a new dial");

        let Some(membership) = &self.current_membership else {
            return Err(Error::NoPeers);
        };

        let node = membership
            .choose_remote_nodes(&mut self.rng, 1)
            .next()
            .ok_or(Error::NoPeers)?;

        let opts = DialOpts::peer_id(node.id)
            .condition(PeerCondition::Always)
            .addresses(vec![node.address.clone()])
            .build();
        self.pending_dials
            .insert((node.id, opts.connection_id()), message);
        self.events.push_back(ToSwarm::Dial { opts });
        self.try_wake();
        Ok(())
    }

    /// Handles [`FromSwarm::DialFailure`] event from the swarm
    /// by rescheduling a new dial if necessary.
    fn handle_dial_failure(&mut self, failure: DialFailure) {
        tracing::error!(target: LOG_TARGET, "Dial failure: {failure:?}");

        // Reschedule a new dial only if the failure is from
        // the connection that this NetworkBehaviour has requested.
        if let Some(message) = self.get_messsage_of_failed_dial(failure) {
            tracing::debug!(target: LOG_TARGET, "Rescheduling dial");
            if let Err(e) = self.schedule_dial(message) {
                tracing::error!(target: LOG_TARGET, "Failed to reschedule dial: {e}");
            }
        }
    }

    /// Handles [`ToBehaviour::SendError`] event from the connection handler
    /// by rescheduling a new dial.
    fn handle_send_error(&mut self, error: SendError) {
        tracing::error!(target: LOG_TARGET, "Failed to send message. Reason: {:?}. Rescheduling dial.", error.reason);
        if let Err(e) = self.schedule_dial(error.message) {
            tracing::error!(target: LOG_TARGET, "Failed to reschedule dial: {e}");
        }
    }
}
