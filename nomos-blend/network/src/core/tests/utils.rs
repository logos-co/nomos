use core::{
    convert::Infallible,
    fmt::Debug,
    iter::repeat_with,
    ops::{Deref, DerefMut},
};
use std::time::Duration;

use key_management_system_keys::keys::Ed25519Key;
use libp2p::{
    PeerId, StreamProtocol, Swarm, Transport as _, core::transport::MemoryTransport,
    identity::PublicKey, plaintext, swarm, tcp, yamux,
};
use libp2p_swarm_test::SwarmExt as _;
use nomos_blend_crypto::{keys::Ed25519PublicKey, signatures::Signature};
use nomos_blend_message::{
    PayloadType,
    crypto::proofs::PoQVerificationInputsMinusSigningKey,
    encap::{ProofsVerifier, validated::EncapsulatedMessageWithVerifiedPublicHeader},
    input::EncapsulationInput,
};
use nomos_blend_proofs::{
    quota::{ProofOfQuota, VerifiedProofOfQuota, inputs::prove::public::LeaderInputs},
    selection::{ProofOfSelection, VerifiedProofOfSelection, inputs::VerifyInputs},
};
use nomos_blend_scheduling::message_blend::provers::BlendLayerProof;
use nomos_core::sdp::SessionNumber;
use nomos_libp2p::{NetworkBehaviour, ed25519, upgrade::Version};
use nomos_utils::blake_rng::{BlakeRng, SeedableRng};

pub const PROTOCOL_NAME: StreamProtocol = StreamProtocol::new("/blend/core-behaviour/test");

pub struct TestSwarm<Behaviour>(Swarm<Behaviour>)
where
    Behaviour: NetworkBehaviour;

impl<Behaviour> TestSwarm<Behaviour>
where
    Behaviour: NetworkBehaviour<ToSwarm: Debug> + Send,
{
    /// Creates [`TestSwarm`] with an ephemeral ed25519 keypair generated
    /// randomly.
    pub fn new_ephemeral<BehaviourConstructor>(behaviour_fn: BehaviourConstructor) -> Self
    where
        BehaviourConstructor: FnOnce(&ed25519::Keypair) -> Behaviour,
    {
        Self(Swarm::new_ephemeral_tokio(|identity| {
            behaviour_fn(
                &identity
                    .try_into_ed25519()
                    .expect("The identity generated by libp2p must be ed25519"),
            )
        }))
    }

    /// Creates [`TestSwarm`] with a specific [`Keypair`].
    pub fn new<BehaviourConstructor>(
        identity: &ed25519::Keypair,
        behaviour_fn: BehaviourConstructor,
    ) -> Self
    where
        BehaviourConstructor: FnOnce(&ed25519::Keypair) -> Behaviour,
    {
        let peer_id = PeerId::from(PublicKey::from(identity.public()));
        // Use TCP and Yamus to be compatible with [`Swarm::new_ephemeral_tokio`].
        let transport = MemoryTransport::default()
            .or_transport(tcp::tokio::Transport::default())
            .upgrade(Version::V1)
            .authenticate(plaintext::Config::new(&identity.clone().into()))
            .multiplex(yamux::Config::default())
            .timeout(Duration::from_secs(20))
            .boxed();

        Self(Swarm::new(
            transport,
            behaviour_fn(identity),
            peer_id,
            swarm::Config::with_tokio_executor(),
        ))
    }
}

impl<Behaviour> Deref for TestSwarm<Behaviour>
where
    Behaviour: NetworkBehaviour,
{
    type Target = Swarm<Behaviour>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl<Behaviour> DerefMut for TestSwarm<Behaviour>
where
    Behaviour: NetworkBehaviour,
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

pub struct TestEncapsulatedMessage(EncapsulatedMessageWithVerifiedPublicHeader);

impl TestEncapsulatedMessage {
    pub fn new(payload: &[u8]) -> Self {
        Self(EncapsulatedMessageWithVerifiedPublicHeader::new(
            &generate_valid_inputs(0),
            PayloadType::Data,
            payload.try_into().unwrap(),
        ))
    }

    pub fn new_with_invalid_signature(payload: &[u8]) -> Self {
        let mut self_instance = Self::new(payload);
        *self_instance.0.public_header_mut().signature_mut() = Signature::from([100u8; _]);
        self_instance
    }

    pub fn into_inner(self) -> EncapsulatedMessageWithVerifiedPublicHeader {
        self.0
    }
}

impl Deref for TestEncapsulatedMessage {
    type Target = EncapsulatedMessageWithVerifiedPublicHeader;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for TestEncapsulatedMessage {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

pub struct TestEncapsulatedMessageWithSession(EncapsulatedMessageWithVerifiedPublicHeader);

impl TestEncapsulatedMessageWithSession {
    pub fn new(session: SessionNumber, payload: &[u8]) -> Self {
        Self(EncapsulatedMessageWithVerifiedPublicHeader::new(
            &generate_valid_inputs(session),
            PayloadType::Data,
            payload.try_into().unwrap(),
        ))
    }
}

impl Deref for TestEncapsulatedMessageWithSession {
    type Target = EncapsulatedMessageWithVerifiedPublicHeader;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

fn generate_valid_inputs(session: SessionNumber) -> Vec<EncapsulationInput> {
    repeat_with(|| Ed25519Key::generate(&mut BlakeRng::from_entropy()))
        .take(3)
        .map(|recipient_signing_key| {
            let proofs = session_based_mock_blend_proof(session);
            EncapsulationInput::new(
                Ed25519Key::generate(&mut BlakeRng::from_entropy()),
                &recipient_signing_key.public_key(),
                proofs.proof_of_quota,
                proofs.proof_of_selection,
            )
        })
        .collect::<Vec<_>>()
}

pub struct SessionBasedMockProofsVerifier(pub SessionNumber);

impl ProofsVerifier for SessionBasedMockProofsVerifier {
    type Error = ();

    fn new(public_inputs: PoQVerificationInputsMinusSigningKey) -> Self {
        Self(public_inputs.session)
    }

    fn start_epoch_transition(&mut self, _new_pol_inputs: LeaderInputs) {}

    fn complete_epoch_transition(&mut self) {}

    fn verify_proof_of_quota(
        &self,
        proof: ProofOfQuota,
        _: &Ed25519PublicKey,
    ) -> Result<VerifiedProofOfQuota, Self::Error> {
        let expected_proofs = session_based_mock_blend_proof(self.0);
        if proof == expected_proofs.proof_of_quota {
            Ok(expected_proofs.proof_of_quota)
        } else {
            Err(())
        }
    }

    fn verify_proof_of_selection(
        &self,
        proof: ProofOfSelection,
        _: &VerifyInputs,
    ) -> Result<VerifiedProofOfSelection, Self::Error> {
        let expected_proofs = session_based_mock_blend_proof(self.0);
        if proof == expected_proofs.proof_of_selection {
            Ok(expected_proofs.proof_of_selection)
        } else {
            Err(())
        }
    }
}

fn session_based_mock_blend_proof(session: SessionNumber) -> BlendLayerProof {
    let session_bytes = session.to_le_bytes();
    BlendLayerProof {
        proof_of_quota: VerifiedProofOfQuota::from_bytes_unchecked({
            let mut bytes = [0u8; _];
            bytes[..session_bytes.len()].copy_from_slice(&session_bytes);
            bytes
        }),
        proof_of_selection: VerifiedProofOfSelection::from_bytes_unchecked({
            let mut bytes = [0u8; _];
            bytes[..session_bytes.len()].copy_from_slice(&session_bytes);
            bytes
        }),
        ephemeral_signing_key: Ed25519Key::generate(&mut BlakeRng::from_entropy()),
    }
}

#[derive(Debug, Clone, Copy)]
pub struct AlwaysTrueVerifier;

impl ProofsVerifier for AlwaysTrueVerifier {
    type Error = Infallible;

    fn new(_public_inputs: PoQVerificationInputsMinusSigningKey) -> Self {
        Self
    }

    fn start_epoch_transition(&mut self, _new_pol_inputs: LeaderInputs) {}

    fn complete_epoch_transition(&mut self) {}

    fn verify_proof_of_quota(
        &self,
        proof: ProofOfQuota,
        _signing_key: &Ed25519PublicKey,
    ) -> Result<VerifiedProofOfQuota, Self::Error> {
        Ok(VerifiedProofOfQuota::from_proof_of_quota_unchecked(proof))
    }

    fn verify_proof_of_selection(
        &self,
        proof: ProofOfSelection,
        _: &VerifyInputs,
    ) -> Result<VerifiedProofOfSelection, Self::Error> {
        Ok(VerifiedProofOfSelection::from_proof_of_selection_unchecked(
            proof,
        ))
    }
}
