use crate::{
    crypto::{Ed25519PrivateKey, Ed25519PublicKey, ProofOfQuota, ProofOfSelection, SharedKey},
    error::Error,
};

/// A list of [`EncapsulationInput`]s.
/// This ensures that the number of inputs is (0, `MAX_ENCAPSULATIONS`].
pub struct EncapsulationInputs<const MAX_ENCAPSULATIONS: usize>(Box<[EncapsulationInput]>);

impl<const MAX_ENCAPSULATIONS: usize> EncapsulationInputs<MAX_ENCAPSULATIONS> {
    pub fn new(inputs: Box<[EncapsulationInput]>) -> Result<Self, Error> {
        if inputs.len() > MAX_ENCAPSULATIONS {
            return Err(Error::MaxEncapsulationsExceeded);
        }
        if inputs.is_empty() {
            return Err(Error::EmptyEncapsulationInputs);
        }
        Ok(Self(inputs))
    }

    pub(crate) fn iter(&self) -> impl DoubleEndedIterator<Item = &EncapsulationInput> {
        self.0.iter()
    }

    pub(crate) fn len(&self) -> usize {
        self.0.len()
    }

    /// Returns `MAX_ENCAPSULATIONS` - [`Self::len`].
    pub(crate) fn num_empty_slots(&self) -> usize {
        MAX_ENCAPSULATIONS
            .checked_sub(self.len())
            .expect("len must be <= MAX_ENCAPSULATIONS")
    }
}

/// Input for a single encapsulation,
pub struct EncapsulationInput {
    /// An ephemeral signing key generated by the encapsulating node.
    pub(crate) signing_key: Ed25519PrivateKey,
    /// A shared key derived from the ephemeral encryption key and
    /// the selected blend node's non-ephemeral encryption key.
    /// Encryption keys are derived from the signing keys.
    pub(crate) shared_key: SharedKey,
    /// A proof of quota for the encapsulation.
    pub(crate) proof_of_quota: ProofOfQuota,
    /// A proof of selection of the selected blend node.
    pub(crate) proof_of_selection: ProofOfSelection,
}

impl EncapsulationInput {
    /// Creates a new [`EncapsulationInput`]
    ///
    /// To derive the shared key, the `signing_key` and `blend_node_signing_key`
    /// are converted into encryptions keys.
    #[must_use]
    pub fn new(
        signing_key: Ed25519PrivateKey,
        blend_node_signing_key: &Ed25519PublicKey,
        proof_of_quota: ProofOfQuota,
        proof_of_selection: ProofOfSelection,
    ) -> Self {
        let shared_key = signing_key
            .derive_x25519()
            .derive_shared_key(&blend_node_signing_key.derive_x25519());
        Self {
            signing_key,
            shared_key,
            proof_of_quota,
            proof_of_selection,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::crypto::PROOF_OF_QUOTA_SIZE;

    const MAX_ENCAPSULATIONS: usize = 3;

    #[test]
    fn valid_encapsulation_inputs() {
        let inputs = generate_inputs(2).unwrap();
        assert_eq!(inputs.len(), 2);
        assert_eq!(inputs.num_empty_slots(), MAX_ENCAPSULATIONS - 2);
    }

    #[test]
    fn max_encapsulations_exceeded() {
        assert_eq!(
            generate_inputs(MAX_ENCAPSULATIONS + 1).err(),
            Some(Error::MaxEncapsulationsExceeded)
        );
    }

    #[test]
    fn empty_inputs() {
        assert_eq!(
            generate_inputs(0).err(),
            Some(Error::EmptyEncapsulationInputs)
        );
    }

    fn generate_inputs(cnt: usize) -> Result<EncapsulationInputs<MAX_ENCAPSULATIONS>, Error> {
        EncapsulationInputs::new(
            std::iter::repeat_with(Ed25519PrivateKey::generate)
                .take(cnt)
                .map(|recipient_signing_key| {
                    let recipient_signing_pubkey = recipient_signing_key.public_key();
                    EncapsulationInput::new(
                        Ed25519PrivateKey::generate(),
                        &recipient_signing_pubkey,
                        ProofOfQuota::from([0u8; PROOF_OF_QUOTA_SIZE]),
                        ProofOfSelection::dummy(),
                    )
                })
                .collect::<Vec<_>>()
                .into_boxed_slice(),
        )
    }
}
