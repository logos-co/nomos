use crate::crypto::{
    keys::{Ed25519PrivateKey, Ed25519PublicKey, SharedKey},
    proofs::{quota::ProofOfQuota, selection::ProofOfSelection},
};

/// Input for a single encapsulation,
pub struct EncapsulationInput {
    /// An ephemeral signing key (ESK) generated by the encapsulating node.
    ephemeral_signing_key: Ed25519PrivateKey,
    /// A shared key derived from the ephemeral encryption key and
    /// the selected blend node's non-ephemeral encryption key.
    /// Encryption keys are derived from the signing keys.
    shared_key: SharedKey,
    /// A proof of quota for the encapsulation.
    proof_of_quota: ProofOfQuota,
    /// A proof of selection of the selected blend node.
    proof_of_selection: ProofOfSelection,
}

impl EncapsulationInput {
    /// Creates a new [`EncapsulationInput`]
    ///
    /// To derive the shared key, the `signing_key` and `blend_node_signing_key`
    /// are converted into encryptions keys.
    #[must_use]
    pub fn new(
        ephemeral_signing_key: Ed25519PrivateKey,
        blend_node_signing_key: &Ed25519PublicKey,
        proof_of_quota: ProofOfQuota,
        proof_of_selection: ProofOfSelection,
    ) -> Self {
        let ephemeral_encryption_key = ephemeral_signing_key
            .derive_x25519()
            .derive_shared_key(&blend_node_signing_key.derive_x25519());
        Self {
            ephemeral_signing_key,
            shared_key: ephemeral_encryption_key,
            proof_of_quota,
            proof_of_selection,
        }
    }

    #[must_use]
    pub const fn ephemeral_signing_key(&self) -> &Ed25519PrivateKey {
        &self.ephemeral_signing_key
    }

    #[must_use]
    pub const fn ephemeral_encryption_key(&self) -> &SharedKey {
        &self.shared_key
    }

    #[must_use]
    pub const fn proof_of_quota(&self) -> &ProofOfQuota {
        &self.proof_of_quota
    }

    #[must_use]
    pub const fn proof_of_selection(&self) -> &ProofOfSelection {
        &self.proof_of_selection
    }
}
