use std::{
    collections::{BTreeMap, HashSet},
    panic,
};

use consensus_engine::{
    AggregateQc, Block, LeaderProof, NewView, NodeId, Qc, StandardQc, TimeoutQc, View,
};
use proptest::prelude::*;
use proptest::test_runner::Config;
use proptest_state_machine::{prop_state_machine, ReferenceStateMachine, StateMachineTest};
use system_under_test::ConsensusEngineTest;

prop_state_machine! {
    #![proptest_config(Config {
        // Only run 100 cases by default to avoid running out of system resources
        // and taking too long to finish.
        cases: 100,
        .. Config::default()
    })]

    #[test]
    // run 50 state transitions per test case
    fn happy_path(sequential 1..50 => ConsensusEngineTest);
}

// A reference state machine, which is used to generate state transitions
// and can also be compared against the consensus-engine state mutated by transitions.
// In other words, this is the expected state as a result of each state transition generated by fuzzing.
// We should try to design this reference state as simple/intuitive as possible,
// so that we don't need to replicate the logic implemented in consensus-engine.
#[derive(Clone, Debug)]
pub struct RefState {
    chain: BTreeMap<View, ViewEntry>,
    highest_voted_view: View,
    timeout_detected: bool,
}

#[derive(Clone, Debug, Default, PartialEq)]
struct ViewEntry {
    blocks: HashSet<Block>,
    timeout_qcs: HashSet<TimeoutQc>,
}

impl ViewEntry {
    fn is_new_view(&self) -> bool {
        self.blocks.is_empty() && self.timeout_qcs.is_empty()
    }
}

// State transtitions that will be picked randomly
#[derive(Clone, Debug)]
pub enum Transition {
    ReceiveBlock(Block, bool),
    ApproveBlock(Block, bool),
    LocalTimeout,
    ReceiveTimeoutQc(TimeoutQc),
    ApproveNewView(TimeoutQc, HashSet<NewView>),
    ReceiveBlockAggregatedQc(Block),
    //TODO: consider invalid transitions that must be rejected by consensus-engine
}

const LEADER_PROOF: LeaderProof = LeaderProof::LeaderId { leader_id: [0; 32] };
const SENDER: NodeId = [0; 32];

impl ReferenceStateMachine for RefState {
    type State = Self;

    type Transition = Transition;

    // Initialize the reference state machine
    fn init_state() -> BoxedStrategy<Self::State> {
        let genesis_block = Block {
            view: 0,
            id: [0; 32],
            parent_qc: Qc::Standard(StandardQc::genesis()),
            leader_proof: LEADER_PROOF.clone(),
        };

        Just(RefState {
            chain: BTreeMap::from([(
                genesis_block.view,
                ViewEntry {
                    blocks: HashSet::from([genesis_block]),
                    timeout_qcs: Default::default(),
                },
            )]),
            highest_voted_view: -1,
            timeout_detected: false,
        })
        .boxed()
    }

    // Generate transitions based on the current reference state machine
    fn transitions(state: &Self::State) -> BoxedStrategy<Self::Transition> {
        if state.has_timeout_qc_in_last_view() {
            // include ApproveNewView
            prop_oneof![
                4 => state.transition_approve_new_view(),
                3 => state.transition_receive_block(),
                2 => state.transition_approve_block(),
                1 => Just(Transition::LocalTimeout),
                1 => state.transition_receive_timeout_qc(),
            ]
            .boxed()
        } else if state.last_view_is_new() {
            // include ReceiveBlockAggregatedQc
            prop_oneof![
                4 => state.transition_receive_block_aggregated_qc(),
                2 => state.transition_receive_block(),
                1 => state.transition_approve_block(),
                1 => Just(Transition::LocalTimeout),
            ]
            .boxed()
        } else {
            prop_oneof![
                4 => state.transition_receive_block(),
                2 => state.transition_approve_block(),
                1 => Just(Transition::LocalTimeout),
                1 => state.transition_receive_timeout_qc(),
            ]
            .boxed()
        }
    }

    // Check if the transition is valid for a given reference state, before applying the transition
    // If invalid, the transition will be ignored and a new transition will be generated.
    fn preconditions(state: &Self::State, transition: &Self::Transition) -> bool {
        match transition {
            Transition::ReceiveBlock(_, _) => !state.timeout_detected,
            Transition::ApproveBlock(block, _) => {
                !state.timeout_detected && state.highest_voted_view < block.view
            }
            Transition::LocalTimeout => !state.timeout_detected,
            Transition::ReceiveTimeoutQc(_) => true,
            Transition::ApproveNewView(_, _) => {
                state.timeout_detected && state.has_timeout_qc_in_last_view()
            }
            Transition::ReceiveBlockAggregatedQc(_) => {
                state.timeout_detected && state.last_view_is_new()
            }
        }
    }

    // Apply the given transition on the reference state machine,
    // so that it can be used to generate next transitions and be compared against the real state.
    fn apply(mut state: Self::State, transition: &Self::Transition) -> Self::State {
        match transition {
            Transition::ReceiveBlock(block, is_safe) => {
                if *is_safe {
                    state
                        .chain
                        .entry(block.view)
                        .or_default()
                        .blocks
                        .insert(block.clone());
                }
            }
            Transition::ApproveBlock(block, is_approvable) => {
                if *is_approvable {
                    state.highest_voted_view = block.view;
                }
            }
            Transition::LocalTimeout => {
                state.highest_voted_view = state.chain.last_entry().unwrap().key().clone();
                state.timeout_detected = true;
            }
            Transition::ReceiveTimeoutQc(timeout_qc) => {
                state.timeout_detected = true;
                state
                    .chain
                    .entry(timeout_qc.view)
                    .or_default()
                    .timeout_qcs
                    .insert(timeout_qc.clone());
            }
            Transition::ApproveNewView(timeout_qc, _) => {
                let new_view = timeout_qc.view + 1;
                state.chain.entry(new_view).or_insert(Default::default());
                state.highest_voted_view = new_view;
            }
            Transition::ReceiveBlockAggregatedQc(block) => {
                state
                    .chain
                    .entry(block.view)
                    .or_default()
                    .blocks
                    .insert(block.clone());
                state.timeout_detected = false;
            }
        }

        state
    }
}

impl RefState {
    // Generate a Transition::ReceiveBlock.
    fn transition_receive_block(
        &self,
    ) -> proptest::strategy::Map<proptest::sample::Select<Block>, impl Fn(Block) -> Transition>
    {
        let blocks = self
            .chain
            .iter()
            .rev()
            .take(5)
            .flat_map(|(_view, entry)| entry.blocks.iter().cloned())
            .collect::<Vec<Block>>();
        let (last_view, _) = self.chain.last_key_value().unwrap();
        let last_view = last_view.clone();

        proptest::sample::select(blocks).prop_map(move |parent| -> Transition {
            let block = Self::consecutive_block(&parent);
            let is_safe = block.view >= last_view;
            Transition::ReceiveBlock(block, is_safe)
        })
    }

    // Generate a Transition::ApproveBlock.
    fn transition_approve_block(
        &self,
    ) -> proptest::strategy::Map<proptest::sample::Select<Block>, impl Fn(Block) -> Transition>
    {
        let blocks = self
            .chain
            .iter()
            .rev()
            .take(5)
            .flat_map(|(_view, entry)| entry.blocks.iter().cloned())
            .collect::<Vec<Block>>();
        let highest_voted_view = self.highest_voted_view.clone();

        proptest::sample::select(blocks).prop_map(move |block| {
            let is_approvable = block.view > highest_voted_view;
            Transition::ApproveBlock(block, is_approvable)
        })
    }

    // Generate a Transition::ReceiveTimeoutQc.
    fn transition_receive_timeout_qc(&self) -> Just<Transition> {
        //TODO: more randomness
        let (last_view, entry) = self.chain.last_key_value().unwrap();
        let high_qc_block = entry
            .blocks
            .iter()
            .max_by_key(|block| block.parent_qc.view())
            .unwrap();

        Just(Transition::ReceiveTimeoutQc(TimeoutQc {
            view: last_view.clone(),
            high_qc: high_qc_block.parent_qc.high_qc(),
            sender: SENDER.clone(),
        }))
    }

    // Generate a Transition::ApproveNewView.
    fn transition_approve_new_view(
        &self,
    ) -> proptest::strategy::Map<
        proptest::sample::Select<TimeoutQc>,
        impl Fn(TimeoutQc) -> Transition,
    > {
        //TODO: more randomness
        let timeout_qcs: Vec<TimeoutQc> = self
            .chain
            .last_key_value()
            .unwrap()
            .1
            .timeout_qcs
            .iter()
            .cloned()
            .collect();

        proptest::sample::select(timeout_qcs).prop_map(move |timeout_qc| {
            //TODO: set new_views
            Transition::ApproveNewView(timeout_qc.clone(), HashSet::new())
        })
    }

    // Generate a Transition::ReceiveBlockAggregatedQc.
    fn transition_receive_block_aggregated_qc(&self) -> Just<Transition> {
        let (new_view, _) = self.chain.last_key_value().unwrap();
        //TODO: get high_qc from approve_new_view
        let high_qc = self
            .chain
            .get(&(new_view - 1))
            .unwrap()
            .timeout_qcs
            .iter()
            .max_by_key(|timeout_qc| timeout_qc.high_qc.view)
            .unwrap()
            .clone()
            .high_qc;

        let block = Block {
            id: rand::thread_rng().gen(),
            view: new_view + 1,
            parent_qc: Qc::Aggregated(AggregateQc {
                high_qc: high_qc.clone(),
                view: new_view.clone(),
            }),
            leader_proof: LEADER_PROOF.clone(),
        };

        Just(Transition::ReceiveBlockAggregatedQc(block))
    }

    fn has_timeout_qc_in_last_view(&self) -> bool {
        if let Some((_view, entry)) = self.chain.last_key_value() {
            !entry.timeout_qcs.is_empty()
        } else {
            false
        }
    }

    fn last_view_is_new(&self) -> bool {
        if let Some((_view, entry)) = self.chain.last_key_value() {
            entry.is_new_view()
        } else {
            false
        }
    }

    fn consecutive_block(parent: &Block) -> Block {
        Block {
            // use rand because we don't want this to be shrinked by proptest
            id: rand::thread_rng().gen(),
            view: parent.view + 1,
            parent_qc: Qc::Standard(StandardQc {
                view: parent.view,
                id: parent.id,
            }),
            leader_proof: LEADER_PROOF.clone(),
        }
    }
}

// StateMachineTest defines how transitions are applied to the real state machine
// and what checks should be performed.
impl StateMachineTest for ConsensusEngineTest {
    // SUT is the real state machine that we want to test.
    type SystemUnderTest = Self;

    // A reference state machine that should be compared against the SUT.
    type Reference = RefState;

    // Initialize the SUT state
    fn init_test(
        _ref_state: &<Self::Reference as proptest_state_machine::ReferenceStateMachine>::State,
    ) -> Self::SystemUnderTest {
        ConsensusEngineTest::new()
    }

    // Apply the transition on the SUT state and check post-conditions
    fn apply(
        state: Self::SystemUnderTest,
        _ref_state: &<Self::Reference as proptest_state_machine::ReferenceStateMachine>::State,
        transition: <Self::Reference as proptest_state_machine::ReferenceStateMachine>::Transition,
    ) -> Self::SystemUnderTest {
        println!("{transition:?}");

        match transition {
            Transition::ReceiveBlock(block, is_safe) => {
                let result = panic::catch_unwind(|| state.engine.receive_block(block.clone()));
                if is_safe {
                    assert!(result.is_ok());
                    let result = result.unwrap();
                    assert!(result.is_ok());
                    let engine = result.unwrap();
                    assert!(engine.blocks_in_view(block.view).contains(&block));

                    ConsensusEngineTest { engine }
                } else {
                    assert!(result.is_err() || result.unwrap().is_err());

                    state
                }
            }
            Transition::ApproveBlock(block, is_approvable) => {
                let result = panic::catch_unwind(|| state.engine.approve_block(block.clone()));
                if is_approvable {
                    assert!(result.is_ok());
                    let (engine, _send) = result.unwrap();
                    //TODO: assert 'send'
                    assert_eq!(engine.highest_voted_view(), block.view);

                    ConsensusEngineTest { engine }
                } else {
                    assert!(result.is_err());

                    state
                }
            }
            Transition::LocalTimeout => {
                let (engine, _send) = state.engine.local_timeout();
                assert_eq!(engine.highest_voted_view(), engine.current_view());

                ConsensusEngineTest { engine }
            }
            Transition::ReceiveTimeoutQc(timeout_qc) => {
                let engine = state.engine.receive_timeout_qc(timeout_qc.clone());
                assert_eq!(engine.high_qc().view, timeout_qc.high_qc.view);
                assert_eq!(engine.last_view_timeout_qc(), Some(timeout_qc.clone()));
                assert_eq!(engine.current_view(), timeout_qc.view + 1);

                ConsensusEngineTest { engine }
            }
            Transition::ApproveNewView(timeout_qc, new_views) => {
                let (engine, _send) = state.engine.approve_new_view(timeout_qc.clone(), new_views);
                assert_eq!(engine.highest_voted_view(), timeout_qc.view + 1);
                assert_eq!(engine.high_qc().view, timeout_qc.high_qc.view); //TODO: maybe not true

                ConsensusEngineTest { engine }
            }
            Transition::ReceiveBlockAggregatedQc(block) => {
                let engine = state.engine.receive_block(block.clone()).unwrap();
                assert!(engine.blocks_in_view(block.view).contains(&block));

                ConsensusEngineTest { engine }
            }
        }
    }

    // Check invariants after every transition
    fn check_invariants(
        state: &Self::SystemUnderTest,
        ref_state: &<Self::Reference as ReferenceStateMachine>::State,
    ) {
        let (last_view, entry) = ref_state.chain.last_key_value().unwrap();
        if entry.timeout_qcs.is_empty() {
            assert_eq!(state.engine.current_view(), last_view.clone());
        } else {
            assert_eq!(state.engine.current_view(), last_view + 1);
        }

        assert_eq!(
            state.engine.highest_voted_view(),
            ref_state.highest_voted_view
        );

        //TODO: add more invariants with more public functions of Carnot
    }
}

// SUT is a system (state) that we want to test.
mod system_under_test {
    use consensus_engine::{
        overlay::{FlatOverlay, RoundRobin, Settings},
        *,
    };

    use crate::LEADER_PROOF;

    #[derive(Clone, Debug)]
    pub struct ConsensusEngineTest {
        pub engine: Carnot<FlatOverlay<RoundRobin>>,
    }

    impl ConsensusEngineTest {
        pub fn new() -> Self {
            let engine = Carnot::from_genesis(
                [0; 32],
                Block {
                    view: 0,
                    id: [0; 32],
                    parent_qc: Qc::Standard(StandardQc::genesis()),
                    leader_proof: LEADER_PROOF.clone(),
                },
                FlatOverlay::new(Settings {
                    nodes: vec![[0; 32]],
                    leader: RoundRobin::default(),
                }),
            );

            ConsensusEngineTest { engine }
        }
    }
}
